#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
//원리는 배열의 마지막단에서부터 2를 곱하면서 10을 넘어갈경우 마지막단-1에 1을 추가하는(carry) 방식
int main() {
	int i, j, k, a = 0;
	int x;
	int gegop[701] = {0}, gegop_1[701] = { 0 }; //배열 2개를 701바이트크기로 0으로 초기화
	gegop[700] = 2; //gegop배열의 700번째 배열의 값을 2로 지정
	printf("2의 n승을 입력하시오: ");
	scanf("%d", &x); //원하는 제곱수 입력

	for (i = 1; i < x; i++) { //x번 반복
		for (k = 700; k >= 1; k--) {
			if ((gegop[k] * 2) < 10) {//해당 자릿수(gegop[k])에 들어있는 값에 X2를 해서 10이 넘어가지 않는다면 그냥 그 수에 X2를 해서 그 자리에 집어넣는다.
				gegop[k] = gegop[k] * 2; //gegop[k] 포문을 반복하는동안 2씩 곱합 즉,이게 2의 제곱을 나타내주게 해줌
			}

			else if ((gegop[k] * 2) >= 10) {//gegop[k]에 들어있는 값에 *2를 해서 10이 넘어갈 경우 바로 윗자릿수(gegop_1[k-1])에 +1을 하고 그 자리에는 X2한 값의 일의자리 수를 집어넣는다.
				gegop[k] = (gegop[k] * 2) % 10; //곱하기 2 를 한값을 10으로 나눈 나머지는 gegop[k]에 넣는다
				gegop_1[k - 1] += 1; //carry된 1을 그이전 단에 +1
			}
		}
		for (a = 700; a >= 1; a--) {//gegop_1[a]에 있던 +1들을 gegop[a]에 합쳐준다.
			if (gegop_1[a] == 1) {  //carry된 결과값이 있다면
				gegop[a] += 1; // 그 이전단에 +1 을 한다
				gegop_1[a] = 0; //carry를 넘겼으므로 원래의 0으로 초기화
				if (gegop[a] >= 10) {//이 과정에서 또 10이 넘어가면 그 윗자리수에 +1을 하고 그 자리에는 %10한 값을 남긴다.
					gegop[a] = gegop[a] % 10; 
					gegop[a - 1] += 1;
				}
			}
		}
	}
	i = 0;//i를 재활용 하기 위해서 0으로 정리.
	for (j = 0; j < 700; j++) {//i, j 재활용, 출력값 앞에 있는 0 정리
		if (gegop[j] != 0)  //첫문단 이 0 이아닌 즉 값이존재할때가지 포문을 확인
			break; //만나면 탈출
		else {
			++i;   //아니면 계속 확인
		}
	}
	for (j = i; j <= 700; j++) {//출력값 앞에 있는 0 정리 후 출력. i값은 0이 아닌값부터 확인될것
		if (j % 3 == 0 && i != j) printf(","); //가독성을 위해 ,삽입
		printf("%d", gegop[j]); //원하는 값 출력

	}
	return 0;
}